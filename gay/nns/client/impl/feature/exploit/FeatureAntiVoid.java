package gay.nns.client.impl.feature.exploit;

import gay.nns.client.api.event.interfaces.Subscribe;
import gay.nns.client.api.feature.enums.FeatureCategory;
import gay.nns.client.api.feature.interfaces.FeatureInfo;
import gay.nns.client.api.setting.annotations.SettingMode;
import gay.nns.client.api.setting.annotations.Serialize;
import gay.nns.client.api.setting.annotations.SettingSlider;
import gay.nns.client.impl.event.player.EventUpdate;
import gay.nns.client.impl.event.render.EventRender2D;
import gay.nns.client.api.feature.AbstractFeature;
import gay.nns.client.impl.event.packet.EventPacketSend;
import gay.nns.client.util.player.MovementUtil;
import gay.nns.client.util.player.PlayerUtil;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.util.BlockPos;

import java.util.ArrayList;

@FeatureInfo(name = "AntiVoid", description = "Prevents you from falling into the void", category = FeatureCategory.EXPLOIT)
public class FeatureAntiVoid extends AbstractFeature {

	@Serialize(name = "Mode")
	@SettingMode(modes = {"Vanilla", "Hypixel"})
	public String mode = "Vanilla";

	@Serialize(name = "Fall_Distance")
	@SettingSlider(min = 0.0D, max = 10.0D, increment = 0.05D)
	public double fallDistance = 3.0D;

	// array of packets
	private ArrayList<Packet<?>> packets = new ArrayList<>();

	private BlockPos lastSafePos;

	private boolean shouldBlink;
	private boolean hasBlinked;

	public FeatureAntiVoid() {
		super();
	}

	@Override
	protected void onEnable() {
		super.onEnable();
	}

	@Override
	protected void onDisable() {
		super.onDisable();
	}

	@Subscribe
	public void onRender2D(final EventRender2D render2DEvent) {
		this.setSuffix(mode);
	}

	@Subscribe
	public void onUpdate(final EventUpdate updateEvent) {
		switch (mode.toLowerCase()) {
			case "vanilla", "hypixel" -> {
				if (PlayerUtil.onGround(0.0D) && mc.thePlayer.onGround) {
					this.lastSafePos = new BlockPos(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ);
				}

				if (PlayerUtil.isOverVoid() && this.lastSafePos != null && (double) mc.thePlayer.fallDistance >= 2) {
					shouldBlink = true;
					mc.thePlayer.setPositionAndUpdate(this.lastSafePos.getX(), this.lastSafePos.getY(), this.lastSafePos.getZ());
					MovementUtil.setSpeed(0.0D);
					shouldBlink = false;
				}

				if (mc.thePlayer.isDead) {
					this.lastSafePos = null;
				}
			}
		}
	}

	@Subscribe
	public void onPacketSent(final EventPacketSend packetSendEvent) {
		switch (mode.toLowerCase()) {
			case "hypixel" -> {
				if (shouldBlink) {
					if (packetSendEvent.getPacket() instanceof C03PacketPlayer c03PacketPlayer) {
						packetSendEvent.setCancelled(true);
						// add packet to array packets
						this.packets.add(c03PacketPlayer);
						hasBlinked = true;
					}
				} else if (hasBlinked) {
					// send packets
					this.packets.forEach(mc.getNetHandler()::addToSendQueue);
					// clear array
					this.packets.clear();
					hasBlinked = false;
				}
			}
		}
	}

}
