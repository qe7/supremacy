package gay.nns.client.impl.feature.exploit;

import gay.nns.client.api.event.interfaces.Subscribe;
import gay.nns.client.api.feature.enums.FeatureCategory;
import gay.nns.client.api.feature.interfaces.SerializeFeature;
import gay.nns.client.api.setting.annotations.SettingMode;
import gay.nns.client.api.setting.annotations.SerializeSetting;
import gay.nns.client.api.setting.annotations.SettingSlider;
import gay.nns.client.impl.event.player.EventPreMotion;
import gay.nns.client.impl.event.player.EventUpdate;
import gay.nns.client.impl.event.render.EventRender2D;
import gay.nns.client.api.feature.Feature;
import gay.nns.client.impl.event.packet.EventPacketSend;
import gay.nns.client.util.player.UtilMovement;
import gay.nns.client.util.player.UtilPlayer;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.util.BlockPos;

import java.util.ArrayList;

@SerializeFeature(name = "AntiVoid", description = "Prevents you from falling into the void", category = FeatureCategory.EXPLOIT)
public class FeatureAntiVoid extends Feature {

    @SerializeSetting(name = "Mode")
    @SettingMode(modes = {"Vanilla", "Hypixel", "Position"})
    public String mode = "Vanilla";

    @SerializeSetting(name = "Fall_Distance")
    @SettingSlider(min = 0.0D, max = 10.0D, increment = 0.05D)
    public double fallDistance = 3.0D;

    // array of packets
    private ArrayList<Packet<?>> packets = new ArrayList<>();

    private BlockPos lastSafePos;

    private boolean shouldBlink;
    private boolean hasBlinked;

    public FeatureAntiVoid() {
        super();
    }

    @Override
    protected void onEnable() {
        super.onEnable();
    }

    @Override
    protected void onDisable() {
        super.onDisable();
    }

    @Subscribe
    public void onRender2D(final EventRender2D render2DEvent) {
        this.setSuffix(mode);
    }

    @Subscribe
    public void onPreMotion(EventPreMotion event) {
        switch (mode.toLowerCase()) {
            case "position" -> {
                if (mc.thePlayer.fallDistance > this.fallDistance && UtilPlayer.isOverVoid()) {
                    event.setY(event.getY() + mc.thePlayer.fallDistance);
                }
            }
        }
    }

    @Subscribe

    public void onUpdate(final EventUpdate updateEvent) {
        switch (mode.toLowerCase()) {
            case "vanilla", "hypixel" -> {
                if (UtilPlayer.onGround(0.0D) && mc.thePlayer.onGround) {
                    this.lastSafePos = new BlockPos(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ);
                }

                if (UtilPlayer.isOverVoid() && this.lastSafePos != null && (double) mc.thePlayer.fallDistance >= 2) {
                    shouldBlink = true;
                    mc.thePlayer.setPositionAndUpdate(this.lastSafePos.getX(), this.lastSafePos.getY(), this.lastSafePos.getZ());
                    UtilMovement.setSpeed(0.0D);
                    shouldBlink = false;
                }

                if (mc.thePlayer.isDead) {
                    this.lastSafePos = null;
                }
            }
        }
    }

    @Subscribe
    public void onPacketSent(final EventPacketSend packetSendEvent) {
        switch (mode.toLowerCase()) {
            case "hypixel" -> {
                if (shouldBlink) {
                    if (packetSendEvent.getPacket() instanceof C03PacketPlayer c03PacketPlayer) {
                        packetSendEvent.setCancelled(true);
                        // add packet to array packets
                        this.packets.add(c03PacketPlayer);
                        hasBlinked = true;
                    }
                } else if (hasBlinked) {
                    // send packets
                    this.packets.forEach(mc.getNetHandler()::addToSendQueue);
                    // clear array
                    this.packets.clear();
                    hasBlinked = false;
                }
            }
        }
    }

}
